function editor(matrix) {
    var mousetrap = new Mousetrap();

    // bind keys
    // numbers
    mousetrap.bind('0', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('1', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('2', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('3', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('4', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('5', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('6', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('7', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('8', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('9', function (e, n) {
        keyboardAscii(e, n);
    });

    // lowercase letters
    mousetrap.bind('a', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('b', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('c', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('d', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('e', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('f', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('g', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('h', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('i', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('j', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('k', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('l', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('m', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('n', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('o', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('p', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('q', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('r', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('s', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('t', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('u', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('v', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('w', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('x', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('y', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('z', function (e, n) {
        keyboardAscii(e, n);
    });

    // uppercase letters
    mousetrap.bind('A', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('B', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('C', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('D', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('E', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('F', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('G', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('H', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('I', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('J', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('K', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('L', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('M', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('N', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('O', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('P', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('Q', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('R', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('S', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('T', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('U', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('V', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('W', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('X', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('Y', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('Z', function (e, n) {
        keyboardAscii(e, n);
    });

    // symbols
    mousetrap.bind('\\', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('|', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('!', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('"', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('~', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('%', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('&', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('/', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('(', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind(')', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('=', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('\'', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('?', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('^', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('[', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind(']', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('*', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('+', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('#', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('@', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('Â°', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('<', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('>', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind(',', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind(';', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('.', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind(':', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('-', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('_', function (e, n) {
        keyboardAscii(e, n);
    });
    mousetrap.bind('space', function (e) {
        keyboardAscii(e, " ");
    });

    // bind arrows
    mousetrap.bind('left', function (e, n) {
        keyboardArrow(e, n);
    });
    mousetrap.bind('up', function (e, n) {
        keyboardArrow(e, n);
    });
    mousetrap.bind('right', function (e, n) {
        keyboardArrow(e, n);
    });
    mousetrap.bind('down', function (e, n) {
        keyboardArrow(e, n);
    });

    // bind control
    mousetrap.bind('backspace', function (e, n) {
        keyboardControl(e, n);
    });
    mousetrap.bind('tab', function (e, n) {
        keyboardControl(e, n);
    });
    mousetrap.bind('enter', function (e, n) {
        keyboardControl(e, n);
    });
    mousetrap.bind('esc', function (e, n) {
        keyboardControl(e, n);
    });
    mousetrap.bind('del', function (e, n) {
        keyboardControl(e, n);
    });
    mousetrap.bind('shift', function (e, n) {
        keyboardControl(e, n);
    });
    mousetrap.bind('ctrl', function (e, n) {
        keyboardControl(e, n);
    });
    mousetrap.bind('alt', function (e, n) {
        keyboardControl(e, n);
    });
    mousetrap.bind('meta', function (e, n) {
        keyboardControl(e, n);
    });

    // disabled control
    mousetrap.bind('shift+space', function (e, n) {
        e.preventDefault();
        console.log("disabled: " + n);
        keyboardAscii(e, " ");
    });


    // unused control
    /*
     mousetrap.bind('pageup', function (e, n) {keyboardControl(e, n);});
     mousetrap.bind('pagedown', function (e, n) {keyboardControl(e, n);});
     mousetrap.bind('ins', function (e, n) {keyboardControl(e, n);});
     mousetrap.bind('home', function (e, n) {keyboardControl(e, n);});
     mousetrap.bind('capslock', function (e, n) {keyboardControl(e, n);});
     mousetrap.bind('end', function (e, n) {keyboardControl(e, n);});
     mousetrap.bind('escape', function (e, n) {keyboardControl(e, n);});
     mousetrap.bind('return', function (e, n) {keyboardControl(e, n);});
     */


    // start text editing
    function keyboardAscii(e, n) {
        // stop the event propagation
        e.preventDefault();

        // get the text area
        var edit = d3.select(".textEdit");

        // check if is empty
        if (edit.empty()) {
            console.log("nothing to fill with: " + n);
        } else {
            var data = edit.datum();
            data = data.pages[data.selectedPage];
            var loc = $(".textEdit").parent();

            // insert new char at cursor pos
            data.message.splice(data.cursorIndex, 0, n);

            //insert new font char at cursor pos
            data.font.splice(data.cursorIndex, 0, matrix.selectedFont);

            //insert new blink type at cursor pos
            data.blinking.splice(data.cursorIndex, 0, matrix.selectedBlink);

            // inc cursor index
            data.cursorIndex++;

            // if is a paged message
            if (edit.classed("page")) {
                // Writing the text:
                writePageText(data, loc);

                // Refreshing the cursor:
                matrix.refreshCursor(data);
            }
            // if is a paged message
            else if (edit.classed("scroll")) {
                // Writing the text:
                writeScrollText(data, loc);
            }
        }
    }

    // control detection
    function keyboardControl(e, n) {
        // stop the event propagation
        e.preventDefault();

        // get the text area
        var edit = d3.select(".textEdit");

        // check if is empty
        if (edit.empty()) {
            return;
        }
        var data = edit.datum();
        data = data.pages[data.selectedPage];
        var loc = $(".textEdit").parent();
        var mustRefresh = false;

        switch (n) {
            case "backspace":
            {
                // if is not the first char
                if (data.cursorIndex > 0) {
                    // insert new char at cursor pos
                    data.message.splice(data.cursorIndex - 1, 1);

                    //insert new font char at cursor pos
                    data.font.splice(data.cursorIndex - 1, 1);

                    // inc cursor index
                    data.cursorIndex--;

                    // Must refresh:
                    mustRefresh = true;
                }
                break;
            }
            case "del":
            {
                // if is not the last char
                if (data.cursorIndex < data.message.length) {
                    // insert new char at cursor pos
                    data.message.splice(data.cursorIndex, 1);

                    //insert new font char at cursor pos
                    data.font.splice(data.cursorIndex, 1);

                    // Must refresh:
                    mustRefresh = true;
                }
                break;
            }
            case "enter":
            {
                if (edit.classed("page")) {
                    // insert new char at cursor pos
                    data.message.splice(data.cursorIndex, 0, '\n');

                    //insert new font char at cursor pos
                    data.font.splice(data.cursorIndex, 0, matrix.selectedFont);

                    // inc cursor index
                    data.cursorIndex++;

                    // Must refresh:
                    mustRefresh = true;
                }
                break;
            }
        }

        // if is a paged message
        if (edit.classed("page")) {
            // Only if needed:
            if (mustRefresh) {
                // Writing the text:
                writePageText(data, loc);

                // Refreshing the cursor:
                matrix.refreshCursor(data);
            }
        }
        // if is a scroll message
        else if (edit.classed("scroll")) {
            // Only if needed:
            if (mustRefresh) {
                // Writing the text:
                writeScrollText(data, loc);
            }
        }
    }

    // move arrow detection
    function keyboardArrow(e, n) {
        // stop the event propagation
        e.preventDefault();

        // get the paged text area
        var edit = d3.select(".textEdit");
        var parent = $(".textEdit").parent();

        // check if is empty
        if (edit.empty()) {
            return;
        }

        var data = edit.datum();
        data = data.pages[data.selectedPage];


        // if is a paged message
        if (edit.classed("page")) {
            //if is not empty start
            var chars = parent.find("g.char");
            var currentX = data.cursorCurrXPos - parseFloat(parent.attr("x"));
            var i;
            var j;
            var rowIndex;
            var row = [];
            var prevY;
            var isNewline;
            var newRow;
            var xS;
            var p;
            var charY;
            var closest;


            switch (n) {
                case "left":
                {
                    // if is not the first
                    if (data.cursorIndex > 0) {

                        // inc cursor index
                        data.cursorIndex--;
                    }
                    break;
                }
                case "right":
                {
                    // if is not the last
                    if (data.cursorIndex < data.message.length) {

                        // inc cursor index
                        data.cursorIndex++;
                    }
                    break;
                }
                case "down":
                {
                    j = 0;
                    rowIndex = null;
                    row = [];
                    prevY = 0;

                    row[j] = [];

                    // if the message is not empty
                    if (data.message.length != 0) {

                        // insert all the rows in the array
                        for (i = 0; i < data.message.length; i++) {
                            p = $(chars[i]);
                            charY = parseFloat(p.attr("dy"));

                            if (prevY != charY) {
                                prevY = charY;
                                j++;
                                row[j] = [];
                            }
                            row[j].push(p);
                        }

                        // search what is the involved row
                        for (i in row) {
                            if (data.cursorCurrYPos - parseFloat(parent.attr("y")) == parseFloat(row[i][0].attr("dy"))) {
                                rowIndex = i;
                            }
                        }

                        // if is not the last row
                        if (rowIndex < row.length - 1) {
                            newRow = parseInt(rowIndex) + 1;

                            // insert the last point of each letters in an array
                            xS = [];
                            for (j in row[newRow]) {
                                xS.push(parseFloat(row[newRow][j].attr("dx")) + parseFloat(row[newRow][j].attr("width")));
                            }

                            // find the closest point in the array with the cursor position
                            closest = xS.reduce(function (prev, curr) {
                                return (Math.abs(curr - currentX) < Math.abs(prev - currentX) ? curr : prev);
                            });

                            // select the index of the nearest element
                            for (j in row[newRow]) {
                                if (parseFloat(row[newRow][j].attr("dx")) + parseFloat(row[newRow][j].attr("width")) == closest) {
                                    data.cursorIndex = parseFloat(row[newRow][j].attr("index")) + 1;
                                }
                            }
                        } else {
                            // if is the last row put the cursor at the end of the message
                            data.cursorIndex = data.message.length;
                        }
                    }
                    break;
                }
                case "up":
                {
                    j = 0;
                    rowIndex = null;
                    row = [];
                    prevY = 0;

                    row[j] = [];

                    // if the message is not empty
                    if (data.message.length != 0) {

                        // insert all the rows in the array
                        for (i = 0; i < data.message.length; i++) {
                            p = $(chars[i]);
                            charY = parseFloat(p.attr("dy"));

                            if (prevY != charY) {
                                prevY = charY;
                                j++;
                                row[j] = [];
                            }
                            row[j].push(p);
                        }

                        // search what is the involved row
                        for (i in row) {
                            if (data.cursorCurrYPos - parseFloat(parent.attr("y")) == parseFloat(row[i][0].attr("dy"))) {
                                rowIndex = i;
                            }
                        }

                        // if is not the first row
                        if (rowIndex > 0) {
                            isNewline = data.message[data.cursorIndex - 1] === '\n';
                            newRow = parseInt(rowIndex) - 1;

                            // insert the last point of each letters in an array
                            xS = [];
                            for (j in row[newRow]) {
                                xS.push(parseFloat(row[newRow][j].attr("dx")) + parseFloat(row[newRow][j].attr("width")));
                            }

                            // find the closest point in the array with the cursor position
                            closest = xS.reduce(function (prev, curr) {
                                return (Math.abs(curr - currentX) < Math.abs(prev - currentX) ? curr : prev);
                            });

                            // select the index of the nearest element
                            for (j in row[newRow]) {
                                if (parseFloat(row[newRow][j].attr("dx")) + parseFloat(row[newRow][j].attr("width")) == closest) {
                                    data.cursorIndex = parseFloat(row[newRow][j].attr("index")) + 1;
                                    // special case: second line first column, append to first line first column
                                    if (isNewline && data.cursorIndex == 1) {
                                        data.cursorIndex = 0;
                                    }
                                }
                            }

                        } else {
                            // if is the first row put the cursor at the start of the message
                            data.cursorIndex = 0;
                        }
                    }
                    break;
                }
            }

            // Refreshing the cursor position and font selection:
            matrix.refreshCursor(data);
        }
        // if is a scrolling message
        else if (edit.classed("scroll")) {
            switch (n) {
                case "left":
                case "up":
                {
                    // if is not the first
                    if (data.cursorIndex > 0) {

                        // inc cursor index
                        data.cursorIndex--;
                    }
                    break;
                }
                case "right":
                case "down":
                {
                    // if is not the last
                    if (data.cursorIndex < data.message.length) {

                        // inc cursor index
                        data.cursorIndex++;
                    }
                    break;
                }
            }

            var loc = $(".textEdit").parent();
            matrix.refreshScrollText(data, loc);
        }
    }
}